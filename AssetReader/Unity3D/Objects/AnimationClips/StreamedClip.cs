namespace SoarCraft.QYun.AssetReader.Unity3D.Objects.AnimationClips {
    using Utils;
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;

    public class StreamedClip {
        public uint[] data;
        public uint curveCount;

        public StreamedClip(ObjectReader reader) {
            data = reader.ReadUInt32Array();
            curveCount = reader.ReadUInt32();
        }

        public class StreamedCurveKey {
            public int index;
            public float[] coeff;

            public float value;
            public float outSlope;
            public float inSlope;

            public StreamedCurveKey(UnityReader reader) {
                index = reader.ReadInt32();
                coeff = reader.ReadSingleArray(4);

                outSlope = coeff[2];
                value = coeff[3];
            }

            public float CalculateNextInSlope(float dx, StreamedCurveKey rhs) {
                //Stepped
                if (coeff[0] == 0f && coeff[1] == 0f && coeff[2] == 0f) {
                    return float.PositiveInfinity;
                }

                dx = Math.Max(dx, 0.0001f);
                var dy = rhs.value - value;
                var length = 1.0f / (dx * dx);
                var d1 = outSlope * dx;
                var d2 = dy + dy + dy - d1 - d1 - coeff[1] / length;
                return d2 / dx;
            }
        }

        public class StreamedFrame {
            public float time;
            public StreamedCurveKey[] keyList;

            public StreamedFrame(UnityReader reader) {
                time = reader.ReadSingle();

                var numKeys = reader.ReadInt32();
                keyList = new StreamedCurveKey[numKeys];
                for (var i = 0; i < numKeys; i++) {
                    keyList[i] = new StreamedCurveKey(reader);
                }
            }
        }

        public List<StreamedFrame> ReadData() {
            var frameList = new List<StreamedFrame>();
            var buffer = new byte[data.Length * 4];
            Buffer.BlockCopy(data, 0, buffer, 0, buffer.Length);
            using (var reader = new UnityReader(new MemoryStream(buffer))) {
                while (reader.BaseStream.Position < reader.BaseStream.Length) {
                    frameList.Add(new StreamedFrame(reader));
                }
            }

            for (var frameIndex = 2; frameIndex < frameList.Count - 1; frameIndex++) {
                var frame = frameList[frameIndex];
                foreach (var curveKey in frame.keyList) {
                    for (var i = frameIndex - 1; i >= 0; i--) {
                        var preFrame = frameList[i];
                        var preCurveKey = preFrame.keyList.FirstOrDefault(x => x.index == curveKey.index);
                        if (preCurveKey != null) {
                            curveKey.inSlope = preCurveKey.CalculateNextInSlope(frame.time - preFrame.time, curveKey);
                            break;
                        }
                    }
                }
            }
            return frameList;
        }
    }
}
